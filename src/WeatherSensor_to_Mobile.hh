// This C++ header file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/6 R2A
// for U-VINNU\Vinnu (Vinnu@Vinnu) on Tue May 30 02:45:58 2017

// Copyright (c) 2000-2017 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

#ifndef WeatherSensor__to__Mobile_HH
#define WeatherSensor__to__Mobile_HH

#ifdef TITAN_RUNTIME_2
#error Generated code does not match with used runtime.\
 Code was generated without -R option but -DTITAN_RUNTIME_2 was used.
#endif

/* Header file includes */

#include <TTCN3.hh>

#if TTCN3_VERSION != 60200
#error Version mismatch detected.\
 Please check the version of the TTCN-3 compiler and the base library.\
 Run make clean and rebuild the project if the version of the compiler changed recently.
#endif

#ifndef WIN32
#error This file should be compiled on WIN32
#endif

#undef WeatherSensor__to__Mobile_HH
#endif

namespace WeatherSensor__to__Mobile {

/* Forward declarations of classes */

class weatherRequest;
class weatherRequest_template;
class weatherResponse;
class weatherResponse_template;
class weatherPort_BASE;
class weatherPort;
class servicePort_BASE;
class servicePort;

} /* end of namespace */

#ifndef WeatherSensor__to__Mobile_HH
#define WeatherSensor__to__Mobile_HH

namespace WeatherSensor__to__Mobile {

/* Type definitions */

typedef COMPONENT MTCType1;
typedef COMPONENT_template MTCType1_template;
typedef COMPONENT MTCType2;
typedef COMPONENT_template MTCType2_template;

/* Class definitions */

class weatherRequest {
  CHARSTRING field_location;
  CHARSTRING field_date;
  CHARSTRING field_kind;
public:
  weatherRequest();
  weatherRequest(const CHARSTRING& par_location,
    const CHARSTRING& par_date,
    const CHARSTRING& par_kind);
  weatherRequest(const weatherRequest& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  weatherRequest& operator=(const weatherRequest& other_value);
  boolean operator==(const weatherRequest& other_value) const;
  inline boolean operator!=(const weatherRequest& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline CHARSTRING& location()
    {return field_location;}
  inline const CHARSTRING& location() const
    {return field_location;}
  inline CHARSTRING& date()
    {return field_date;}
  inline const CHARSTRING& date() const
    {return field_date;}
  inline CHARSTRING& kind()
    {return field_kind;}
  inline const CHARSTRING& kind() const
    {return field_kind;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class weatherRequest_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
weatherRequest_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const weatherRequest& other_value);
void copy_template(const weatherRequest_template& other_value);

public:
weatherRequest_template();
weatherRequest_template(template_sel other_value);
weatherRequest_template(const weatherRequest& other_value);
weatherRequest_template(const OPTIONAL<weatherRequest>& other_value);
weatherRequest_template(const weatherRequest_template& other_value);
~weatherRequest_template();
weatherRequest_template& operator=(template_sel other_value);
weatherRequest_template& operator=(const weatherRequest& other_value);
weatherRequest_template& operator=(const OPTIONAL<weatherRequest>& other_value);
weatherRequest_template& operator=(const weatherRequest_template& other_value);
boolean match(const weatherRequest& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
weatherRequest valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
weatherRequest_template& list_item(unsigned int list_index) const;
CHARSTRING_template& location();
const CHARSTRING_template& location() const;
CHARSTRING_template& date();
const CHARSTRING_template& date() const;
CHARSTRING_template& kind();
const CHARSTRING_template& kind() const;
int size_of() const;
void log() const;
void log_match(const weatherRequest& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class weatherResponse {
  CHARSTRING field_location;
  CHARSTRING field_date;
  CHARSTRING field_kind;
  INTEGER field_temperature;
  INTEGER field_windVelocity;
  CHARSTRING field_conditions;
public:
  weatherResponse();
  weatherResponse(const CHARSTRING& par_location,
    const CHARSTRING& par_date,
    const CHARSTRING& par_kind,
    const INTEGER& par_temperature,
    const INTEGER& par_windVelocity,
    const CHARSTRING& par_conditions);
  weatherResponse(const weatherResponse& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  weatherResponse& operator=(const weatherResponse& other_value);
  boolean operator==(const weatherResponse& other_value) const;
  inline boolean operator!=(const weatherResponse& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline CHARSTRING& location()
    {return field_location;}
  inline const CHARSTRING& location() const
    {return field_location;}
  inline CHARSTRING& date()
    {return field_date;}
  inline const CHARSTRING& date() const
    {return field_date;}
  inline CHARSTRING& kind()
    {return field_kind;}
  inline const CHARSTRING& kind() const
    {return field_kind;}
  inline INTEGER& temperature()
    {return field_temperature;}
  inline const INTEGER& temperature() const
    {return field_temperature;}
  inline INTEGER& windVelocity()
    {return field_windVelocity;}
  inline const INTEGER& windVelocity() const
    {return field_windVelocity;}
  inline CHARSTRING& conditions()
    {return field_conditions;}
  inline const CHARSTRING& conditions() const
    {return field_conditions;}
  inline int size_of() const
    {return 6;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class weatherResponse_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
weatherResponse_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const weatherResponse& other_value);
void copy_template(const weatherResponse_template& other_value);

public:
weatherResponse_template();
weatherResponse_template(template_sel other_value);
weatherResponse_template(const weatherResponse& other_value);
weatherResponse_template(const OPTIONAL<weatherResponse>& other_value);
weatherResponse_template(const weatherResponse_template& other_value);
~weatherResponse_template();
weatherResponse_template& operator=(template_sel other_value);
weatherResponse_template& operator=(const weatherResponse& other_value);
weatherResponse_template& operator=(const OPTIONAL<weatherResponse>& other_value);
weatherResponse_template& operator=(const weatherResponse_template& other_value);
boolean match(const weatherResponse& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
weatherResponse valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
weatherResponse_template& list_item(unsigned int list_index) const;
CHARSTRING_template& location();
const CHARSTRING_template& location() const;
CHARSTRING_template& date();
const CHARSTRING_template& date() const;
CHARSTRING_template& kind();
const CHARSTRING_template& kind() const;
INTEGER_template& temperature();
const INTEGER_template& temperature() const;
INTEGER_template& windVelocity();
const INTEGER_template& windVelocity() const;
CHARSTRING_template& conditions();
const CHARSTRING_template& conditions() const;
int size_of() const;
void log() const;
void log_match(const weatherResponse& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class weatherPort_BASE : public PORT {
enum msg_selection { MESSAGE_0 };
struct msg_queue_item : public msg_queue_item_base {
msg_selection item_selection;
union {
weatherResponse *message_0;
};
component sender_component;
};

void remove_msg_queue_head();
protected:
void clear_queue();
public:
weatherPort_BASE(const char *par_port_name);
~weatherPort_BASE();
void send(const weatherRequest& send_par, const COMPONENT& destination_component);
void send(const weatherRequest& send_par);
void send(const weatherRequest_template& send_par, const COMPONENT& destination_component);
void send(const weatherRequest_template& send_par);
protected:
virtual void outgoing_send(const weatherRequest& send_par) = 0;
public:
alt_status receive(const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
alt_status check_receive(const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
alt_status trigger(const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
alt_status receive(const weatherResponse_template& value_template, weatherResponse *value_redirect, const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
alt_status check_receive(const weatherResponse_template& value_template, weatherResponse *value_redirect, const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
alt_status trigger(const weatherResponse_template& value_template, weatherResponse *value_redirect, const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
private:
void incoming_message(const weatherResponse& incoming_par, component sender_component);
protected:
inline void incoming_message(const weatherResponse& incoming_par) { incoming_message(incoming_par, SYSTEM_COMPREF); }
boolean process_message(const char *message_type, Text_Buf& incoming_buf, component sender_component, OCTETSTRING& slider);
};

class servicePort_BASE : public PORT {
enum msg_selection { MESSAGE_0 };
struct msg_queue_item : public msg_queue_item_base {
msg_selection item_selection;
union {
weatherRequest *message_0;
};
component sender_component;
};

void remove_msg_queue_head();
protected:
void clear_queue();
public:
servicePort_BASE(const char *par_port_name);
~servicePort_BASE();
void send(const weatherResponse& send_par, const COMPONENT& destination_component);
void send(const weatherResponse& send_par);
void send(const weatherResponse_template& send_par, const COMPONENT& destination_component);
void send(const weatherResponse_template& send_par);
protected:
virtual void outgoing_send(const weatherResponse& send_par) = 0;
public:
alt_status receive(const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
alt_status check_receive(const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
alt_status trigger(const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
alt_status receive(const weatherRequest_template& value_template, weatherRequest *value_redirect, const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
alt_status check_receive(const weatherRequest_template& value_template, weatherRequest *value_redirect, const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
alt_status trigger(const weatherRequest_template& value_template, weatherRequest *value_redirect, const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
private:
void incoming_message(const weatherRequest& incoming_par, component sender_component);
protected:
inline void incoming_message(const weatherRequest& incoming_par) { incoming_message(incoming_par, SYSTEM_COMPREF); }
boolean process_message(const char *message_type, Text_Buf& incoming_buf, component sender_component, OCTETSTRING& slider);
};


/* Function prototypes */

extern void weather__Office();
extern void start_weather__Office(const COMPONENT& component_reference);
extern void weather__Service(const weatherResponse_template& serviceFrankfurtResponse);
extern void start_weather__Service(const COMPONENT& component_reference, const weatherResponse_template& serviceFrankfurtResponse);
extern verdicttype testcase_testWeather(const weatherResponse_template& serviceFrankfurtResponse, boolean has_timer, double timer_value);

/* Global variable declarations */

extern const XERdescriptor_t weatherRequest_location_xer_;
extern const TTCN_JSONdescriptor_t weatherRequest_location_json_;
extern const TTCN_Typedescriptor_t weatherRequest_location_descr_;
extern const XERdescriptor_t weatherRequest_date_xer_;
extern const TTCN_JSONdescriptor_t weatherRequest_date_json_;
extern const TTCN_Typedescriptor_t weatherRequest_date_descr_;
extern const XERdescriptor_t weatherRequest_kind_xer_;
extern const TTCN_JSONdescriptor_t weatherRequest_kind_json_;
extern const TTCN_Typedescriptor_t weatherRequest_kind_descr_;
extern const TTCN_Typedescriptor_t weatherRequest_descr_;
extern const weatherRequest_template& FrankfurtWeekendWeatherRequest;
extern const weatherRequest_template& officeFrankfurtWeekendWeatherRequest;
extern const XERdescriptor_t weatherResponse_location_xer_;
extern const TTCN_JSONdescriptor_t weatherResponse_location_json_;
extern const TTCN_Typedescriptor_t weatherResponse_location_descr_;
extern const XERdescriptor_t weatherResponse_date_xer_;
extern const TTCN_JSONdescriptor_t weatherResponse_date_json_;
extern const TTCN_Typedescriptor_t weatherResponse_date_descr_;
extern const XERdescriptor_t weatherResponse_kind_xer_;
extern const TTCN_JSONdescriptor_t weatherResponse_kind_json_;
extern const TTCN_Typedescriptor_t weatherResponse_kind_descr_;
extern const XERdescriptor_t weatherResponse_temperature_xer_;
extern const TTCN_JSONdescriptor_t weatherResponse_temperature_json_;
extern const TTCN_Typedescriptor_t weatherResponse_temperature_descr_;
extern const XERdescriptor_t weatherResponse_windVelocity_xer_;
extern const TTCN_JSONdescriptor_t weatherResponse_windVelocity_json_;
extern const TTCN_Typedescriptor_t weatherResponse_windVelocity_descr_;
extern const XERdescriptor_t weatherResponse_conditions_xer_;
extern const TTCN_JSONdescriptor_t weatherResponse_conditions_json_;
extern const TTCN_Typedescriptor_t weatherResponse_conditions_descr_;
extern const TTCN_Typedescriptor_t weatherResponse_descr_;
extern const weatherResponse_template& FrankfurtResponse;
extern const weatherResponse_template& serviceFrankfurtResponse1;
extern const weatherResponse_template& serviceFrankfurtResponse2;
extern const TTCN_Typedescriptor_t& MTCType1_descr_;
extern weatherPort MTCType1_component_weatherOffice;
extern const TTCN_Typedescriptor_t& MTCType2_descr_;
extern servicePort MTCType2_component_weatherService;
extern TTCN_Module module_object;

} /* end of namespace */

/* Test port header files */

#include "weatherPort.hh"
#include "servicePort.hh"

#endif
